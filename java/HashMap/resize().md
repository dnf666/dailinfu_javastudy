# resize() 方法

1. 查看 table 是否有初始化过, 然后重新设定容量与阈值大小
2. 如果有初始化过
  1. 检查是否大于或者等于最大的限定 `1<<30`, 如果如果是, 则把阈值设定为最大常数
  2. 如果不是, 那下一次扩容如果没有益处, 并且旧的容量大与等于默认的初始容量, 如果是右移一个单位(乘以2)
3. 如果没有初始化过检查是否设定了负载因子
4. 如果都没有初始化table并且没有设定阈值, 那么重新计算阈值与设定容量大小
5. 最后检查一次阈值, 如果阈值还是为0, 再次计算一次阈值
6. 设定完容量大小与阈值后, 开始重新设定 table
7. 设定阈值与初始化 table 数组
8. 遍历旧的 table 数组, 取出元素并设定旧的 table 数组的元素位置为空
9. 如果是一个 Node 节点, 重新通过 hash 值计算位置
10. 如果是 TreeNode 调用 `split()`
11. 如果是 Node 链表, 遍历 table 中的头元素, 重新散列冲突的元素
12. 用元素的 hash 值与原来的容量做比较, 如果为 0 则表示以前的哈希值的容量位置对应的 1 的地方也为 0, 那么用新的来散列的话还是原来的位置, 就记录到新的链表 loHead 当中
13. 如果做 & 运算的结果为 1 , 那么就表示新的容量 length - 1 来计算桶位置的时候, 它的高位会影响它的新位置, 那么就记录到 hiHead 当中
14. 把 loHead 链表赋值给原来桶的位置, 把 hiHead 赋值给新的桶位置(原来的桶位置+原来的容量)

*散列冲突寻找新的桶位置的原理如下*

```
// 原理

/**

假设原本的容量为 16
对应的二进制为 0001 0000

新的容量为 32
对应的二进制为 0010 0000

对象的 hash = 0001 0101

那么在原有的桶位置为

0000 1111
0001 0101
---------
0000 0101 = 5

也就只有后4位起了作用

在新的桶位置的位置为

0001 1111
0001 0101
---------
0001 0101 = 21 = 5 + 16

便是后5位起了作用

而原本的桶容量的二进制刚好为五位, 就可以验证 hash 码的第五位是否为 1 , 如果为 1 , 就需要改变对象在新桶当中的位置

**/
```
