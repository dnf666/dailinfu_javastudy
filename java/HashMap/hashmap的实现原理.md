hashmap是以key-value键值对存储的数据结构。它的内部维护了一个entry数组，每一个数组元素都是一个链表。在put时候。通过key对象的hashcode值确定插入元素的位置。如果没发生了hash冲突，就将数组保存在数组中。如果发生了hash冲突就将元素以链表的结构存储。同样在get的时候。通过key对象的hashcode值确定查询元素的位置。如果当前数组的位置上的元素的正好相等。就返回。如果不相等，就遍历该位置的链表。直到查找到确定元素。否则返回空
    hashmap在达到一定容量后，会发生扩容。扩大为原来的2倍。所有元素的位置都要重新计算。
    我觉得hashmap在确定元素位置设计的比较好。使用了扰乱函数。将hashcode的高16位和低16位进行按位与运算。大大增加元素分布的均匀性。在java8中，hashmap的查询性能得到提升。在某一位置的链表个数达到8个的时候，会发生树形化操作。将链表结构改为红黑树结构。查询复杂度由0（n）降低为o(logn)。当元素减少到6个的时候。又会重新变为链表结构。
    hashmap是非线程安全的，key和value可以为null，在多线程情况下使用会造成cpu100%的情况。如果要在多线程使用hashmap
    可以考虑线程安全的concurrenthashmap和hashtable。


####为什么是8树形化。6还原成链表
    红黑树的平均查找长度是logn，链表的平均查找长度是n/2.当8的时候是红黑树是3.链表为4.
    红黑树比较快。所以要树形化。当6的时候。红黑树log6，链表3.虽然还是红黑树快一点。但是要转成红黑树还需要耗费性能。所以保持链表结构。中间有个7。我认为这个7是用来防止树和链表频繁转换的。如果hashmap一直来回插入删除同一个位置的元素。而该位置的元素个数一直在8和7变换。导致hashmap频繁树形化和还原。影响性能
