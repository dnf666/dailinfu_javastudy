1. nginx
    nginx动态代理配置，
    nginx网络模型
    为什么选nginx，不选apache
2. spring缓存
    为什么选spring缓存
     哪儿做了spring缓存
     spring缓存怎么配置
3. sql优化
    如何sql优化
    
    select * from account user where 
    索引优化
     优化的那一条
     
4. docker
    docker部署
    为什么用docker
    docker pull
    docker run -d -s
    
    docker hub


5. 遗传算法
    这个算法的主要思想是基于达尔文的进化论，物种都是朝着好的方向发展。
    首先取出数据库内所有的中心点和服务点。项目中的场景是一个中心点和多个服务点
    中心点和服务点用数组保存，数组首尾是中心点，中间是服务点
    
    第一步是初始化，随机产生路径方案。用math.ramdom方法随机互换数组中服务点元素的位置
    这样就得到了一条路线方案。用同样的方法总生成10条
        获取到所有的服务点，通过随机函数随机取n个点，每取一个点都要从原数组中剔除
        组成第一个路径后，检查原数组是否已经取出完成。如果没取出完成就继续随机取点
        作为新的路线。一个方案对应多个路线
    
    第二步计算之前生成的路线的距离。每条路线距离越短，权重越大
    用一个treemap来保存计算结果，距离作为key，路线对象作为value。
    这个时候还需要保存所有路线的最短距离，平均距离，最大距离
    
    第三步  轮盘赌 也就是产生下一代并且发生变异 只有距离小于平均距离的路线才能产生下一代
    对每个满足要求的路线互换其中的一些元素。然后随机改变里面的某个元素。
    
    第四步 计算 新一代的距离，与treemap中的最后一个元素比较，如果距离比它短，则替换他。
    这样我就得到了新的一代路径。
    
    最后 重复我之前的做法，如果treemap中的最短距离连续5代都没有发生变化。则可以认为这是最优的路径
    
    