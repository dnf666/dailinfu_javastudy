# CMS 收集器

CMS 属于老年代垃圾回收器, 采用标记 - 清除算法

CMS 的目标是尽可能的减少回收停顿时间, 从而提高用户的响应时间和体验度

CMS 是一款并发的垃圾收集器, 在它的并发标记与并发清除阶段, 不需要暂停用户线程

CMS 工作分作四个步骤
1. 初始标记(Stop the world) 只需要简单标记一下 GC Root 能直接关联到的对象
2. 并发标记
3. 重新标记(Stop the world)
4. 并发清除
其中时间开销 T(并发标记) > T(重新标记) > T(初始标记)

由于整个过程中耗时最长的并发标记阶段和并发清除阶段过程, 垃圾收集器都可以与用户线程一起工作, 所以总体上来讲 CMS 收集器的回收过程是和用户线程并发工作的

缺点有三点
1. CMS 对 CPU 资源敏感, 因为与用户线程一起工作, 所以会抢占用户线程的 CPU 资源, 导致用户线程的执行效率下降
2. CMS 无法收集浮动垃圾, 可能会导致 Concurrent Mode Failure 失败而导致另一次 Full GC 的产生. 浮动垃圾是当垃圾回收器在运行的适合产生的新的垃圾. Concurrent Mode Failure 是当 CMS 运行期间, 预留给用户的内存不够, 这是 JVM 会启动备用方案: 使用 Serial Old 垃圾收集器来回收老年代, 这个适合就需要 Stop the world, 所以预留给用户的内存比例不能太小
3. CMS 基于标记 - 清除算法实现的, 所以会产生很多空间碎片

CMS 适用于 Server 端, 需要重视服务的响应速度, 系统停顿时间最短的应用

CMS 可以搭配 Serial & ParNew 年轻代垃圾回收器一起工作
