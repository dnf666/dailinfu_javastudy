#### 哈希索引

哈希索引是基于哈希表实现的, 对与每一行数据, 存储引擎都会对所有的索引列计算一个哈希码, 不同的哈希码也不一样, 哈希索引将所有的哈希码存储在索引当中, 同时也创建一个哈希表, 在这个哈希表当中保存指向每个数据行的指针, 它适合于精确匹配查找, 与 B-Tree 不同的是非常的快

Mysql 当中, 只有 Memory 引擎现实支持哈希索引, Memory 引擎也是默认把哈希索引当中索引类型

##### 有效的查询

- 精确匹配索引的所有列的查询

##### 限制

- 必须要整个索引键才能唯一确定一行
- 没有办法提高 ORDER BY 操作
- 哈希索引一定会读取数据行, 因为哈希索引只保存了哈希值和行指针, 不会保存字段值
- 哈希索引并不按照索引值顺序存储的, 索引也就无法用于排序
- 哈希索引是把所有的索引列都用来计算才能得到唯一的哈希值, 所以也就没有办法使用部分索引列匹配查询
- 哈希索引只支持等值比较查询, 不能做范围查询
- 如果哈希冲突很高的话, 那么就需要遍历所有这个索引值可能生成的哈希值

##### InnoDB 使用哈希的优化

InnoDB 的索引使用 B-Tree 来实现, 但是如果引擎发现某一个索引值会被频繁的访问到, 那么就会计算它的哈希码, 然后基于 B-Tree 的数据结构生成一个哈希索引, 这样就具备了一些哈希的基本优点

例如: 当有一个表存放了一些关于网页的信息`id, url, name, context`, 使用 B-Tree 的查找方法一般为 `select id from table where url='http://www.mysql.com'`, 如果这个时候表很大查找起来就会很慢, 这个时候如果新加入一列 url 的哈希码使表变成 `id, url ,name ,context, hash`, 并且使用这个查找方法`select id from table where url='http://www.mysql.com' and hash=CRC32('http://www.mysql.com')`, 那么引擎会优先根据选择性很高而且体积很小的一列也就是 **hash** 这一列来查找, 这个时候就会得到一些索引条目, 然后一一比较返回对应的行, 就可以得到内容

*!* CRC32() 返回32位整数, 当索引条目为 93000 条记录的时候, 出现冲突的概率为 1%
