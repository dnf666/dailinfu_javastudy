# 查询优化器

一个合法的语法解析树有很多中执行的方式, 查询解析器根据自身的模型选择一条最合适的执行方式去执行

优化策略的参考因素: **每个表或者索引的页面个数** **索引的基数** **索引和数据行的长度** **索引的分布情况**

## 优化策略的分类

静态优化和动态优化

- 静态优化 类似于“静态编译”, 在整个查询当中执行一次, 静态优化执行一次后就一直存在, 例如在 `where` 条件当中通过一些简单的代数变换换成另外的一种等价方式
- 动态优化 类似于“动态编译”, 每次查询的时候都需要根据上下文的信息和别的因素来动态调节

## 优化类型

- 重新定义关联表的顺序
- 外链接转化成一个内链接, 只是将等价于内连接的外连接操作转化成内连接
- 等价变换规则简化表达式, 例如 (5 = 5 AND a > 5) 优化成 a > 5
- 优化 `COUNT(*)` 一些索引当中会记录表的行数, 所以这个函数相当于一个常数
- MIN() MAX() 优化 在基于 B-Tree 数据结构的索引上, MIN() 相当于 B-Tree 最左边的数, MAX() 相当于最右边的数
- 覆盖索引扫描 如果索引当中有数据行, 那么就可以直接获取到数据
- 子查询优化 MYSQL 可以在特定情况下, 将子查询转化成一种效率更高的形式
