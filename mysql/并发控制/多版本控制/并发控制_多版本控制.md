## 多版本控制

多版本控制是为了提升并发的性能, 在很多情况下避免了加锁的操作, 因此和锁对比起来开销更低, 所以 MVCC 只是在 **读操作** 远多于 **写操作** 的情况下

MVCC 只在 **REPEATETABLE READ** **READ COMMITTED** 两个隔离级别下工作

### 工作方式

在 InnoDB 当中, MVCC 会在每一行记录后面保存两个隐藏的列, 一个保存了 **行的创建时间**, 一个保存了 **行的过期时间**, 这两个时间是系统版本号, 每一次事务开始的时候会自动递增, 然后把这个版本号当作事务的版本号, 用来和查询得到的每行记录的版本号进行比较, 这样每一次事务开始的时候都得到了这个时间点的数据快照, 无论事务需要运行多长的时间都可以使得它的数据是一样的

MVCC 的具体工作方式要分四种 **SELECT** **INSERT** **DELETE** **UPDATE**

#### SELECT

**SELECT** 的操作通常会返回一个数据集, 所以 MVCC 模式下的 SELECT 会以下面两个要求来塞选数据

- InnoDB 只查找比当前事务把版本早的系统版本, 也就是说行的系统版本要小于或者等于当前事务版本, 这样可以确保得到的每一行数据, 要么是事务开始前就存在的, 要么是事务自己插入或者修改的
- **行的过期时间** 标记要么没有定(为空) 要么大于当前的事务版本号(这样就表示事务读取到这一行的时候, 这个数据是没有被删除的)


#### INSERT

- 每插入一行新的数据就在这行数据的 **行创建时间** 当中填入当前事务的版本号

#### DELETE

- 删除一行数据的时候就更新这行数据的 **行过期时间** 为当前事务的版本号

#### UPDATE

- 将插入一行新的数据, 把这行新的数据的 **行创建时间** 填入当前事务版本号, 将原被更新的数据的 **行过期时间** 更新为当前事务版本号
